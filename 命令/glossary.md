| 术语 | 定义 |
| ---------------------- | ------------------------------------------------------------ |
| base image | A **base image** has no parent image specified in its Dockerfile. It is created using a Dockerfile with the `FROM scratch` directive. |
| boot2docker | [boot2docker](http://boot2docker.io/) is a lightweight Linux distribution made specifically to run Docker containers. The boot2docker management tool for Mac and Windows was deprecated and replaced by [`docker-machine`](https://docs.docker.com/glossary/#machine) which you can install with the Docker Toolbox. |
| btrfs | btrfs (B-tree file system) is a Linux [filesystem](https://docs.docker.com/glossary/#filesystem) that Docker supports as a storage backend. It is a [copy-on-write](http://en.wikipedia.org/wiki/Copy-on-write) filesystem. |
| cluster | A cluster is a group of machines that work together to run workloads and provide high availability. |
| Compose | [Compose](https://github.com/docker/compose) is a tool for defining and running complex applications with Docker. With Compose, you define a multi-container application in a single file, then spin your application up in a single command which does everything that needs to be done to get it running. |
| copy-on-write | Docker uses a [copy-on-write](https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/#/the-copy-on-write-strategy) technique and a [union file system](https://docs.docker.com/glossary/#union_file_system) for both images and containers to optimize resources and speed performance. Multiple copies of an entity share the same instance and each one makes only specific changes to its unique layer.Multiple containers can share access to the same image, and make container-specific changes on a writable layer which is deleted when the container is removed. This speeds up container start times and performance.Images are essentially layers of filesystems typically predicated on a base image under a writable layer, and built up with layers of differences from the base image. This minimizes the footprint of the image and enables shared development.For more about copy-on-write in the context of Docker, see [Understand images, containers, and storage drivers](https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/). |
| Docker | The term Docker can refer to - The Docker project as a whole, which is a platform for developers and sysadmins to develop, ship, and run applications - The docker daemon process running on the host which manages images and containers (also called Docker Engine) |
| container | A container is a runtime instance of a [docker image](https://docs.docker.com/glossary/#image).A Docker container consists of - A Docker image - An execution environment - A standard set of instructions. The concept is borrowed from Shipping Containers, which define a standard to ship goods globally. Docker defines a standard to ship software. |
| filesystem | A file system is the method an operating system uses to name files and assign them locations for efficient storage and retrieval. (Linux : ext4, aufs, btrfs, zfs; Windows : NTFS; macOS : HFS+) |
| image | Docker images are the basis of [containers](https://docs.docker.com/glossary/#container). An Image is an ordered collection of root filesystem changes and the corresponding execution parameters for use within a container runtime. An image typically contains a union of layered filesystems stacked on top of each other. An image does not have state and it never changes. |
| layer | In an image, a layer is modification to the image, represented by an instruction in the Dockerfile. Layers are applied in sequence to the base image to create the final image. When an image is updated or rebuilt, only layers that change need to be updated, and unchanged layers are cached locally. This is part of why Docker images are so fast and lightweight. The sizes of each layer add up to equal the size of the final image. |
| libcontainer | libcontainer provides a native Go implementation for creating containers with namespaces, cgroups, capabilities, and filesystem access controls. It allows you to manage the lifecycle of the container performing additional operations after the container is created. |
| libnetwork | libnetwork provides a native Go implementation for creating and managing container network namespaces and other network resources. It manages the networking lifecycle of the container performing additional operations after the container is created. |
| Machine | [Machine](https://github.com/docker/machine) is a Docker tool which makes it really easy to create Docker hosts on your computer, on cloud providers and inside your own data center. It creates servers, installs Docker on them, then configures the Docker client to talk to them. |
| node | A [node](https://docs.docker.com/engine/swarm/how-swarm-mode-works/nodes/) is a physical or virtual machine running an instance of the Docker Engine in [swarm mode](https://docs.docker.com/glossary/#swarm_mode).**Manager nodes** perform swarm management and orchestration duties. By default manager nodes are also worker nodes.**Worker nodes** execute tasks. |
| overlay network driver | Overlay network driver provides out of the box multi-host network connectivity for docker containers in a cluster. |
| overlay storage driver | OverlayFS is a [filesystem](https://docs.docker.com/glossary/#filesystem) service for Linux which implements a [union mount](http://en.wikipedia.org/wiki/Union_mount) for other file systems. It is supported by the Docker daemon as a storage driver. |
| parent image | An image’s **parent image** is the image designated in the `FROM` directive in the image’s Dockerfile. All subsequent commands are based on this parent image. A Dockerfile with the `FROM scratch` directive uses no parent image, and creates a **base image**. |
| persistent storage | Persistent storage or volume storage provides a way for a user to add a persistent layer to the running container’s file system. This persistent layer could live on the container host or an external device. The lifecycle of this persistent layer is not connected to the lifecycle of the container, allowing a user to retain state. |
| registry | A Registry is a hosted service containing [repositories](https://docs.docker.com/glossary/#repository) of [images](https://docs.docker.com/glossary/#image) which responds to the Registry API.The default registry can be accessed using a browser at [Docker Hub](https://docs.docker.com/glossary/#docker hub) or using the `docker search` command. |
| repository | A repository is a set of Docker images. A repository can be shared by pushing it to a [registry](https://docs.docker.com/glossary/#registry) server. The different images in the repository can be labeled using [tags](https://docs.docker.com/glossary/#tag).Here is an example of the shared [nginx repository](https://hub.docker.com/_/nginx/) and its [tags](https://hub.docker.com/r/library/nginx/tags/). |
| service | A [service](https://docs.docker.com/engine/swarm/how-swarm-mode-works/services/) is the definition of how you want to run your application containers in a swarm. At the most basic level a service defines which container image to run in the swarm and which commands to run in the container. For orchestration purposes, the service defines the “desired state”, meaning how many containers to run as tasks and constraints for deploying the containers. Frequently a service is a microservice within the context of some larger application. Examples of services might include an HTTP server, a database, or any other type of executable program that you wish to run in a distributed environment. |
| service discovery | Swarm mode [service discovery](https://docs.docker.com/engine/swarm/networking/#use-swarm-mode-service-discovery) is a DNS component internal to the swarm that automatically assigns each service on an overlay network in the swarm a VIP and DNS entry. Containers on the network share DNS mappings for the service via gossip so any container on the network can access the service via its service name. You don’t need to expose service-specific ports to make the service available to other services on the same overlay network. The swarm’s internal load balancer automatically distributes requests to the service VIP among the active tasks. |
| swarm | A [swarm](https://docs.docker.com/engine/swarm/) is a cluster of one or more Docker Engines running in [swarm mode](https://docs.docker.com/glossary/#swarm_mode). |
| Docker Swarm | Do not confuse [Docker Swarm](https://github.com/docker/swarm) with the [swarm mode](https://docs.docker.com/glossary/#swarm_mode) features in Docker Engine.Docker Swarm is the name of a standalone native clustering tool for Docker. Docker Swarm pools together several Docker hosts and exposes them as a single virtual Docker host. It serves the standard Docker API, so any tool that already works with Docker can now transparently scale up to multiple hosts. |
| swarm mode | [Swarm mode](https://docs.docker.com/engine/swarm/) refers to cluster management and orchestration features embedded in Docker Engine. When you initialize a new swarm (cluster) or join nodes to a swarm, the Docker Engine runs in swarm mode. |
| tag | A tag is a label applied to a Docker image in a [repository](https://docs.docker.com/glossary/#repository). Tags are how various images in a repository are distinguished from each other. *Note : This label is not related to the key=value labels set for docker daemon.* |
| task | A [task](https://docs.docker.com/engine/swarm/how-swarm-mode-works/services/#/tasks-and-scheduling) is the atomic unit of scheduling within a swarm. A task carries a Docker container and the commands to run inside the container. Manager nodes assign tasks to worker nodes according to the number of replicas set in the service scale. The diagram below illustrates the relationship of services to tasks and containers.![services diagram](../插图/services-diagram.png) |
| volume | A volume is a specially-designated directory within one or more containers that bypasses the Union File System. Volumes are designed to persist data, independent of the container’s life cycle. Docker therefore never automatically deletes volumes when you remove a container, nor will it “garbage collect” volumes that are no longer referenced by a container. There are three types of volumes: *host, anonymous, and named*: A **host volume** lives on the Docker host’s filesystem and can be accessed from within the container. A **named volume** is a volume which Docker manages where on disk the volume is created, but it is given a name. An **anonymous volume** is similar to a named volume, however, it can be difficult, to refer to the same volume over time when it is an anonymous volumes. Docker handle where the files are stored. |
